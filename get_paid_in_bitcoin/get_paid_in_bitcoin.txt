
Now, Python has a library of Bitcoin tools called pybitcointools (https://github.com/vbuterin/pybitcointools),
so the first thing you will need to do is install python via your method of choice if you don't have it
already, and then use Python's package manager pip to install pybitcointools:

`pip install bitcoin`

In an Elixir project, the `priv` directory is reserved for artifacts that you
need alongside your Elixir code, so that's where we'll put the python code, which
we'll call `bitcoin_address.py`. First, we need a function that will create
a Bitcoin public key from a private key, so we'll write it like this:

```
import bitcoin

def create_bitcoin_public_key(private_key):
  decoded_private_key = bitcoin.decode_privkey(private_key, "hex")
  public_key = bitcoin.fast_multiply(bitcoin.G, decoded_private_key)
  (public_key_x, public_key_y) = public_key
  compressed_prefix = "02" if (public_key_y % 2) == 0 else "03"
  return compressed_prefix + bitcoin.encode(public_key_x, 16, 64)
```

So, here in our `create_bitcoin_public_key` function, we do the following:

- use the `bitcoin` library to decode the private key from a hex string into
  an integer
- We then use the `bitcoin` library's `fast_multiply` function, which calculates
  a public key point on the Elliptic Curve
- ...which is destructured on the next line here as an x and y tuple, both x and y here are huge integers
- We then determine how the public key should be prefixed
- and then concatinate the prefix with the hex value of the public key x coordinate

And that gives us our Bitcoin public key, and we ended using 3 functions and 1 constant (the bitcoin.G elliptic curve parameter).
So, how do we talk to this file from Elixir? With Export, a hex package that
wraps around Erlport, which is an Erlang library that enables you to talk both
Python and Ruby code.

To use Export, we'll first add it to our mix file and run `mix deps.get`:

```
  defp deps do
    [
      # Erlport wrapper for Elixir to interface with Python code
      {:export, "~> 0.1.0"}
    ]
  end
```

And now let's make a file for the Python integration:

```
defmodule BitcoinAddress.Python do
  use Export.Python

  @python_path :bitcoin_address |> :code.priv_dir() |> Path.basename()
  @python_file "bitcoin_address"

  def generate(private_key) do
    with {:ok, pid} <- Python.start(python_path: @python_path),
         bitcoin_public_key <- create_bitcoin_public_key(pid, private_key) do
      IO.puts("Private key: #{inspect(private_key)}")
      IO.puts("Public key: #{inspect(bitcoin_public_key)}")
      Python.stop(pid)
    end
  end

  defp create_bitcoin_public_key(pid, private_key) do
    pid
    |> Python.call(@python_file, "create_bitcoin_public_key", [private_key])
    |> to_string()
  end
end
```

Going through the code:

- We need to tell export which directory to go and look for Python files...
- ...and then specifically what the file name is, without the .py extension
- We then call Python.start to spawn off a process to the Python directory
  which gives us back its process ID
- Which we then pass to the create_bitcoin_public_key function, along with the
  private_key we want to create a Bitcoin public key for.
- There, we run Python.call send to the Python file the name of the function we want to
  call, ("create_bitcoin_public_key"), and a list of parameters
- Since the response that we get back from Python will be a binary, we cast it
  back into a string.

So, that takes care of public key, but what about the bitcoin address? pybitcointools
has a function called `bitcoin.pubkey_to_address`, that we can call directly
through Export, without having to write any more Python code, so let's add that in:

```
defmodule BitcoinAddress.Python do
  use Export.Python

  @python_path :bitcoin_address |> :code.priv_dir() |> Path.basename()
  @python_file "bitcoin_address"

  def generate(private_key) do
    with {:ok, pid} <- Python.start(python_path: @python_path),
         bitcoin_public_key <- create_bitcoin_public_key(pid, private_key),
         bitcoin_address <- create_bitcoin_address(pid, bitcoin_public_key) do
      IO.puts("Private key: #{inspect(private_key)}")
      IO.puts("Public key: #{inspect(bitcoin_public_key)}")
      IO.puts("Bitcoin address: #{inspect(bitcoin_address)}")
      Python.stop(pid)
    end
  end

  defp create_bitcoin_public_key(pid, private_key) do
    pid
    |> Python.call(@python_file, "create_bitcoin_public_key", [private_key])
    |> to_string()
  end

  defp create_bitcoin_address(pid, bitcoin_pub_key) do
    pid
    |> Python.call(@python_file, "bitcoin.create_bitcoin_public_key", [bitcoin_pub_key])
    |> to_string()
  end
end
```

Notice here that we're calling a function directly on the `bitcoin` module
that is imported in the Python file. That is accessible to us from Elixir. Now,
with some minor refactoring we have our finished implementation:

```
defmodule BitcoinAddress.Python do
  use Export.Python

  @python_path :bitcoin_address |> :code.priv_dir() |> Path.basename()
  @python_file "bitcoin_address"

  def generate(private_key) do
    with {:ok, pid} <- Python.start(python_path: @python_path),
         bitcoin_public_key <- create_bitcoin_public_key(pid, private_key),
         bitcoin_address <- create_bitcoin_address(pid, bitcoin_public_key) do
      IO.puts("Private key: #{inspect(private_key)}")
      IO.puts("Public key: #{inspect(bitcoin_public_key)}")
      IO.puts("Bitcoin address: #{inspect(bitcoin_address)}")
      Python.stop(pid)
    end
  end

  defp create_bitcoin_public_key(pid, private_key) do
    call_python(pid, "create_bitcoin_public_key", [private_key])
  end

  defp create_bitcoin_address(pid, bitcoin_pub_key) do
    call_python(pid, "bitcoin.pubkey_to_address", [bitcoin_pub_key])
  end

  defp call_python(pid, function, args) do
    pid
    |> Python.call(@python_file, function, args)
    |> to_string()
  end
end
```

So, let's give it a try in an iex terminal:

```
iex(1)> private_key = :crypto.strong_rand_bytes(32) |> Base.encode16()
"1542BC5E590628E5C3A1C355869B1B773B055EDF57A633D58F9C0938BA2CDE0B"
iex(2)> BitcoinAddress.Python.generate(private_key)
Private key: "1542BC5E590628E5C3A1C355869B1B773B055EDF57A633D58F9C0938BA2CDE0B"
Public key: "022dc34a77f936876375190971e31f152a68d2ff7687985b33822f36a78b4eab15"
Bitcoin address: "1Amc3fz6ZmiwqEDbEZwm7eVJZH8ApXBAqY"
```

We first generate a 256 bit (or 32 byte) private key using Erlang's crypto module and encode it into
a hex string, then pass it over to Python, and as you can see, we have our
Base58 Bitcoin address, ready to receive all the crypto! So, as far as we
know, the address has been generated correctly. We're assuming that the
pybitcointools generated it correctly.

So, to sanity check, let's get C++ to do
the same thing and see if we get back the same result. As you would probably expect,
doing this is quite a lot more involved, and we'll need a bit of guidance
getting things set up, so let's get the Cure hex package to help us out.

First, though, we'll need to install the necessary C++ Bitcoin libraries we'll be
calling, in this case libbitcoin, and we can do this simply with Homebrew:

`brew install libbitcoin`

Then, add Cure to the mix file and run mix deps.get:

```
  defp deps do
    [
      # Interface C-code with Erlang/Elixir using Ports
      {:cure, "~> 0.4.0"},
      # Erlport wrapper for Elixir to interface with Python code
      {:export, "~> 0.1.0"}
    ]
  end
```

Then, get Cure to generate the necessary base files to communicate between
C++ and Elixir:

```sh
mix cure.bootstrap
```

This command will add the following files to a top-level `c_src` directory
which is Erlang convention for the location of C source code since compiled
C executables will be what goes in the `priv` directory:

```text
c_src
├── Makefile
├── main.c
└── main.h
```

- `Makefile`: a template to automatically build a C++ executable including
  Cure's libraries. We'll leave this for now, but get back to it later on.
- `main.c`: Cure's base C file to communicate between C/C++ and Elixir.
- `main.h`: The header file for `main.c`

The first thing we'll do take a look inside the main.c file to see how Cure is
expecting us to communicate with C.

```
#include "main.h"
int main(void) {
  int bytes_read;
  byte buffer[MAX_BUFFER_SIZE];

  while((bytes_read = read_msg(buffer)) > 0) {
    // TODO put C-code here, right now it only echos data back
    // to Elixir.
    send_msg(buffer, bytes_read);
  }
  return 0;
}
```

So, when Elixir spawns a Cure process, it will call the main function which will
kick off the while loop, where messages will be explicitly read in from Elixir
via the read_msg function, and we send messages back to Elixir via the send_msg
function, and when we eventually terminate the Cure process from Elixir, we
break out of the while loop, and the C code finishes running. Okay, I think we
got it.

Before we start writing code, since we are dealing with C++ Bitcoin libraries,
we will need to rename the files appropriately, which is something we can easily
do since C++ files can also run C code:

```
mv c_src/main.h c_src/bitcoin_address.h
mv c_src/main.c c_src/bitcoin_address.cpp
```

Next, we'll get to implementing a create_bitcoin_public_key function, which
will look something like this. First define the function in the header file:

```
#ifndef BITCOIN_ADDRESS_H
#define BITCOIN_ADDRESS_H
#include <elixir_comm.h>

std::string generate_bitcoin_public_key(std::string priv_key);

#endif
```

And then the implementation:

```
#include <string>
#include "bitcoin_address.h"

int main(void) {
 // ...
}

std::string generate_bitcoin_public_key(std::string priv_key) {
  bc::ec_secret decoded;
  bc::decode_base16(decoded, priv_key);

  bc::wallet::ec_private secret(decoded, bc::wallet::ec_private::mainnet_p2kh);

  // Get public key.
  bc::wallet::ec_public public_key(secret);
  return public_key.encoded();
}
```

Similar to the Python code, this function
- takes in a hex-encoded private key
- Decodes it into an integer
- Calculates a public key point on the Elliptic Curve
- Generates a public key from that point and returns it.

So, that's all well and good, but how can we use this function from Elixir?
Unlike Export, where we are able to send messages to any Python library directly and
get values returned, here, we're tied to the C++ `main` function, which brings in
messages from Elixir in a buffer of bytes.

```
int main(void) {
  int bytes_read;
  byte buffer[MAX_BUFFER_SIZE];

  while((bytes_read = read_msg(buffer)) > 0) {
    // TODO put C-code here, right now it only echos data back
    // to Elixir.
    send_msg(buffer, bytes_read);
  }
  return 0;
}
```

In order to call the generate_bitcoin_public_key function, we can't just send
the private key from Elixir and expect that C++ will know what to do with it:
we'll need to send a flag along as well, that will allow the C++ program to
determine what function to be called, and the easiest type of flag in this case
is an integer, so, let's say that the integer 1 stands for generating a bitcoin
public key, and we want to be able to extract that as the first byte of the message
from Elixir.

```
const int GENERATE_BITCOIN_PUBLIC_KEY = 1;

int main(void) {
  int bytes_read;
  byte buffer[MAX_BUFFER_SIZE];

  while((bytes_read = read_msg(buffer)) > 0) {
    // TODO put C-code here, right now it only echos data back
    // to Elixir.
    send_msg(buffer, bytes_read);
  }
  return 0;
}
```

So we will need a function that processes a message that includes information
about what command is to be called, so let's call that `process_command`

```
const int GENERATE_BITCOIN_PUBLIC_KEY = 1;

int main(void) {
  int bytes_read;
  byte buffer[MAX_BUFFER_SIZE];

  while((bytes_read = read_msg(buffer)) > 0) {
    process_command(buffer, bytes_read);
  }
  return 0;
}
```

After declaring the `process_command` in the header file, let's have a look at
what its details could look like:

```
void process_command(byte* buffer, int bytes_read) {
  int function = buffer[0];
  std::string arg = (char*) &buffer[1];
  std::string result;

  if (bytes_read > 0) {
    switch (function) {
      case GENERATE_BITCOIN_PUBLIC_KEY:
        result = generate_bitcoin_public_key(arg);
        break;
      default:
        fprintf(stderr, "not a valid function %i\n", function);
        exit(1);
    }
    memcpy(buffer, result.data(), result.length());
    send_msg(buffer, result.size());
  }
}
```

We take the buffer and number of bytes read as arguments to the function, and
from the buffer we extract the first byte to determine which function to call,
and then we declare the function argument arg to be a pointer at the second byte of the buffer
and cast it to a string, which for our purposes is equivalent to assigning the
contents of the buffer, minus the function name byte to the `arg` variable.

From there, we take the function integer, switch on it, call the function that
maps to it, and assign it to a `result` string. We then overwrite the contents
of the current buffer with the result of generate_bitcoin_public_key, and send
it back to Elixir via the `send_msg` function provided by Cure.

Quite a bit more involved than Python, right? So, how does this look on the Elixir side?
Kind of similar as the actions we're performing from the Elixir point of view are
similar:

```
defmodule BitcoinAddress.CPlusPlus do
  alias Cure.Server, as: Cure

  @cpp_executable "priv/bitcoin_address"
  # Integers representing C++ methods
  @generate_public_key 1

  def generate(private_key) do
    with {:ok, pid} <- Cure.start_link(@cpp_executable),
         bitcoin_public_key <- create_bitcoin_public_key(pid, private_key) do
      IO.puts("Private key: #{inspect(private_key)}")
      IO.puts("Bitcoin public key: #{inspect(bitcoin_public_key)}")
      :ok = Cure.stop(pid)
    end
  end

  defp create_bitcoin_public_key(pid, private_key) do
    Cure.send_data(pid, <<@generate_public_key, private_key::binary>>, :once)

    receive do
      {:cure_data, response} ->
        response
    end
  end
end
```

- We need to tell Cure where to look for the C++ executable file
  (generation of which we'll look at in just a moment, suffice to say that even though
  C code itself lives in the `c_src` directory, the executable will get compiled out
  to the priv directory with the Python code)
- We define mirroring integers that map to the C++ functions, so there's necessary
  tight coupling here
- We then call Cure.start_link to spawn off a process to the executable
  which gives us back its process ID
- Which we then pass to the create_bitcoin_public_key function, along with the
  private_key we want to create a Bitcoin public key for.
- There, using the power of Elixir binaries that allow us to tinker with the innards
  of a sequence of bytes, we use Cure.send_data send a binary to the C++ executable consisting of
  the integer for the function we want to call, ("create_bitcoin_public_key"),
  and the rest of the message payload, in this case the private key, and the
  atom `:once` to indicate that we only want a single message back from Cure and
  we don't need to listen for any other returned messages.
- Cure returns the response from C++ to our process mailbox, which we receive
  and simply return back.

So now we have the Bitcoin public key, what about the address? Let's add that
in to the C++ file as a function called `create_bitcoin_address`, that takes
in a Bitcoin public key, and returns a Base58 Bitcoin address:

```
std::string create_bitcoin_address(std::string pub_key) {
  bc::wallet::ec_public public_key = bc::wallet::ec_public::ec_public(pub_key);
  bc::data_chunk public_key_data;
  public_key.to_data(public_key_data);
  const auto hash = bc::bitcoin_short_hash(public_key_data);
  bc::data_chunk unencoded_address;
  unencoded_address.reserve(25);
  unencoded_address.push_back(0);
  bc::extend_data(unencoded_address, hash);
  bc::append_checksum(unencoded_address);
  const std::string address = bc::encode_base58(unencoded_address);
  return address;
}
```

Most of the code for this function comes straight out of the Mastering Bitcoin
book and I have it in a Github repo if you care to do more detailed analysis,
but suffice to say it does the same thing as the Python function equivalent,
giving us back a Bitcoin address.

In order to be able to call this function, we will also need to modify the
process command method to be able to call it, so let's do that, mapping this
function to the integer 2:

```
const int GENERATE_BITCOIN_PUBLIC_KEY = 1;
const int CREATE_BITCOIN_ADDRESS = 2;

int main(void) { ... }

void process_command(byte* buffer, int bytes_read) {
  int function = buffer[0];
  std::string arg = (char*) &buffer[1];
  std::string result;

  if (bytes_read > 0) {
    switch (function) {
      case GENERATE_BITCOIN_PUBLIC_KEY:
        result = generate_bitcoin_public_key(arg);
        break;
      case CREATE_BITCOIN_ADDRESS:
        retval = create_bitcoin_address(arg);
        break;
      default:
        fprintf(stderr, "not a valid function %i\n", function);
        exit(1);
    }
    memcpy(buffer, result.data(), result.length());
    send_msg(buffer, result.size());
  }
}

std::string generate_public_key(std::string priv_key) { ... }
std::string create_bitcoin_address(std::string pub_key) { ... }
```

Back in Elixir, we perform a similar modification:

```
defmodule BitcoinAddress.CPlusPlus do
  alias Cure.Server, as: Cure

  @cpp_executable "priv/bitcoin_address"
  # Integers representing C++ methods
  @generate_public_key 1
  @create_bitcoin_address 2

  def generate(private_key) do
    with {:ok, pid} <- Cure.start_link(@cpp_executable),
         bitcoin_public_key <- create_bitcoin_public_key(pid, private_key),
         bitcoin_address <- create_bitcoin_address(pid, public_key) do
      IO.puts("Private key: #{inspect(private_key)}")
      IO.puts("Bitcoin public key: #{inspect(bitcoin_public_key)}")
      IO.puts("Bitcoin address: #{inspect(bitcoin_address)}")
      :ok = Cure.stop(pid)
    end
  end

  defp create_bitcoin_public_key(pid, private_key) do
    Cure.send_data(pid, <<@generate_public_key, private_key::binary>>, :once)

    receive do
      {:cure_data, response} ->
        response
    end
  end

  defp create_bitcoin_address(pid, bitcoin_public_key) do
    Cure.send_data(pid, <<@create_bitcoin_address, bitcoin_public_key::binary>>, :once)

    receive do
      {:cure_data, response} ->
        response
    end
  end
end
```

- Create a new module attribute for the C++ `create_bitcoin_address` function
- and add an Elixir create_bitcoin_address function that will send the function
  flag and bitcoin_public_key to C++ and return the response.

With some minor refactoring, we're now finished with this module:

```
defmodule BitcoinAddress.CPlusPlus do
  alias Cure.Server, as: Cure

  @cpp_executable "priv/bitcoin_address"
  # Integers representing C++ methods
  @generate_public_key 1
  @create_bitcoin_address 2

  def generate(private_key) do
    with {:ok, pid} <- Cure.start_link(@cpp_executable),
         bitcoin_public_key <- create_bitcoin_public_key(pid, private_key),
         bitcoin_address <- create_bitcoin_address(pid, bitcoin_public_key) do
      IO.puts("Private key: #{inspect(private_key)}")
      IO.puts("Public key: #{inspect(bitcoin_public_key)}")
      IO.puts("Bitcoin address: #{inspect(bitcoin_address)}")
      :ok = Cure.stop(pid)
    end
  end

  defp create_bitcoin_public_key(pid, private_key) do
    call_cpp(pid, <<@generate_public_key, private_key::binary>>)
  end

  defp create_bitcoin_address(pid, bitcoin_public_key) do
    call_cpp(pid, <<@create_bitcoin_address, bitcoin_public_key::binary>>)
  end

  defp call_cpp(pid, data) do
    Cure.send_data(pid, data, :once)

    receive do
      {:cure_data, response} ->
        response
    end
  end
end
```

Now, before we can attempt to run this, we still have the compilation issue to
deal with and that Makefile from earlier on. Makefiles are not something that
I write at all, and the Makefile and Cure comes with out of the box didn't work
at all with any of my code, so I had to create one from scratch, and this is
what I came up with:

```
CC = g++ -std=c++11
APP_DIR = $(shell dirname $(shell pwd))
CURE_DEPS_DIR = $(APP_DIR)/deps/cure/c_src
CURE_DEPS = -I$(CURE_DEPS_DIR) -L$(CURE_DEPS_DIR)
ELIXIR_COMM_C = -x c++ $(CURE_DEPS_DIR)/elixir_comm.c
LIBBITCOIN_DEPS = $(shell pkg-config --cflags --libs libbitcoin)
C_FLAGS = $(CURE_DEPS) $(ELIXIR_COMM_C) $(LIBBITCOIN_DEPS) -O3
PRIV_DIR = $(APP_DIR)/priv
C_SRC_DIR = $(APP_DIR)/c_src
EXECUTABLES = bitcoin_address

all: $(EXECUTABLES)
# * $< - prerequisite file
# * $@ - executable file
$(EXECUTABLES): %: %.cpp
	$(CC) $(C_FLAGS) $(C_SRC_DIR)/$< -o $(PRIV_DIR)/$@
```

I'm going to spare you the very dry details of this, suffice to say that what
it does is takes any .cpp files that are in the project c_src/ directory, and
compile executables for them into the project priv/ directory. But, the killer
feature of having this is that it enables me to be able to run compliation
via the `mix compile.cure` command. And this can now be done from within mix,
you can do things like:

```
defmodule BitcoinAddress.Mixfile do
  use Mix.Project

  def project do
    [
      # ...
      compilers: Mix.compilers ++ [:cure, :"cure.deps"]
    ]
  end

  # ...
end
```

Have the C++ files also compile whenever you run `mix compile`, or perhaps
independently add their compilation to your mix test.watch pipeline:

```
if Mix.env() == :dev do
  config :mix_test_watch,
    clear: true,
    tasks: [
      "compile.cure",
      "format",
      "test",
      "credo --strict"
    ]
end
```

So, now, let's run the code and see if we get the same values as Python:

```
iex(1)> private_key = :crypto.strong_rand_bytes(32) |> Base.encode16()
"1542BC5E590628E5C3A1C355869B1B773B055EDF57A633D58F9C0938BA2CDE0B"
iex(2)> BitcoinAddress.Python.generate(private_key)
Private key: "1542BC5E590628E5C3A1C355869B1B773B055EDF57A633D58F9C0938BA2CDE0B"
Public key: "022dc34a77f936876375190971e31f152a68d2ff7687985b33822f36a78b4eab15"
Bitcoin address: "1Amc3fz6ZmiwqEDbEZwm7eVJZH8ApXBAqY"
iex(3)> BitcoinAddress.CPlusPlus.generate(private_key)
Private key: "1542BC5E590628E5C3A1C355869B1B773B055EDF57A633D58F9C0938BA2CDE0B"
Public key: "022dc34a77f936876375190971e31f152a68d2ff7687985b33822f36a78b4eab15"
Bitcoin address: "1Amc3fz6ZmiwqEDbEZwm7eVJZH8ApXBAqY"
```

And, it's the same, so it works! Lambos for all!

So, if you find that Elixir does not yet have the libraries to handle the
problems that you want to solve, there are other options available to you using
both compiled and runtime languages.

I've written up two blog posts about using Python and C++ Bitcoin libraries
in Elixir that should hopefully give you all the details that were potentially
absent from this presentation, that you can find here:

- https://paulfioravanti.com/blog/2017/12/04/using-pythons-bitcoin-libraries-in-elixir/
- https://paulfioravanti.com/blog/2017/12/13/using-c-plus-plus-bitcoin-libraries-in-elixir/

The code used in this presentation is contained in its own repo here:

https://github.com/paulfioravanti/bitcoin_address

It is based on the repo that I made to port the code examples from Mastering Bitcoin
over to Elixir, which you can find here:

https://github.com/paulfioravanti/mastering_bitcoin

Ironically enough, while preparing this presentation, I actually figured out
how to generate Bitcoin public keys directly in Elixir
(which you can find in the bitcoin_address repo), so there's no need to
call out to any other language's library for this particular use case, but hopefully
if you're ever called upon to integrate with libraries from other languages, you're
now armed with enough information about your options to know how to start,
but more importantly with more knowledge about Bitcoin addresses, you are now one
step closer to your own lambo, so make sure you give me a ride in it sometime
when you get it.
